import { createStore } from "redux";
import { connect } from "react-redux";
import { store, gameReducer, configureStore } from "./store";
import "Relay.sol";
const { sendAuth, receiveAuth } = require("../authenticate");

//this file is used to interact with the hedera network and the smart contract
//it is used to create a new game, and flip the coin
//it is also used to get the game state from the smart contract

const {
  Client,
  PrngTransaction,
  PublicKey,
  PrivateKey,
  TransferTransaction,
  Hbar,
  AccountId,
  ContractCreateTransaction,
  FileCreateTransaction,
  FileId,
  ContractFunctionParameters,
  ContractExecuteTransaction,
  ContractCallQuery,
  ContractId,
} = require("@hashgraph/sdk");

const fs = require("fs");

const fetch = require("node-fetch");

const dotenv = require("dotenv");

const result = dotenv.config({ path: ".env" });

console.log(result.parsed);
const operatorAcc = AccountId.fromString(process.env.OPERATOR_ID);
const operatorKey = PrivateKey.fromString(process.env.OPERATOR_KEY);

//bytecode in /home/goodchoice/Documents/Website2/hederacoinflip/backend/coinflip_sol_CoinFlip.bin
const byteString = fs.readFileSync();

const client = Client.forTestnet();
client.setOperator(operatorAcc, operatorKey);
store.dispatch({ type: "SET_CLIENT", payload: client });

let playerAddress;
let walletAccessToken = receiveAuth.walletAccessToken;
//smart contracts being accessed by the game:
//0.0.xxxxx - the treasury account
//0.0.xxxxx - the logs smart contract
//0.0.xxxxx - the coinflip smart contract

//coinflip game
//the game will be started by the frontend
//the frontend will send the player's choice and bet amount to the game
//coinflip game uses prng transaction to generate a random number and uses a boolean to determine if the player won or lost
//yes is heads, no is tails
//the game state is stored in the smart contract PlayerStats.sol
//Treasury is not directly accessed by the game, but the game will send the player's winnings to the treasury account via a relay contract
//the game will also send money allocated to the player via a relay contract

//need to verify the game states by sending the game state to the smart contract
//once the game state is verified, the game can start
//the player cannot have another game in progress
//the player must have enough money in their wallet to play the game
//the player must have a wallet that is connected to the game (this is done by the frontend via Hashconnect)
//the treasury account must have enough money to pay the player if they win
//the player account must have enough money to pay the treasury if they lose
//the final game states will be stored in a logs smart contract
//a random number will be generated by hashgraph API, the receipt will be stored in the logs smart contract grouped with each players game state

async function main() {}
//verify the player is connected with hashconnect wallet
//verify the player has enough money in their wallet
//verify the treasury has enough money to pay the player if they win

main();

////////////////////
///App State Functions using store from redux
///////////////////

const appState = {
  gamePhase: ["init", "bet", "flip", "payouts", "end"],
  currentPhase: "init",
  gameWonByPlayer: false,
  actualResult: "",
  contractIdentity: "",

  //player state
  playerAddress: "",
  playerGuess: "",
  betAmount: 0,
  walletConnected: false,
  walletAccessToken: "",
  transferReceipt: "",
  randomReceipt: "",

  //game state
  gamesPlayed: 0,
  isGameActive: false,
};

const setAppState = (_nextPhase) => {
  let currentPhaseIndex = appState.gamePhase.indexOf(appState.currentPhase);
  let nextPhaseIndex = appState.gamePhase.indexOf(_nextPhase);
  if (nextPhaseIndex > -1 && nextPhaseIndex > currentPhaseIndex) {
    appState.currentPhase = _nextPhase;

    //set the game state in the smart contract
    sendAllUserData(
      appState.playerAddress,
      appState.gameWonByPlayer,
      appState.playerGuess,
      appState.actualResult,
      appState.betAmount,
      appState.gamesPlayed,
      appState.walletAccessToken,
      appState.isGameActive
    );
  }
};

const setGamePhase = (_nextPhase) => {
  let currentPhaseIndex = appState.gamePhase.indexOf(appState.currentPhase);
  let nextPhaseIndex = appState.gamePhase.indexOf(_nextPhase);
  if (nextPhaseIndex > -1 && nextPhaseIndex > currentPhaseIndex) {
    appState.currentPhase = _nextPhase;
  }
};

const setGameWonByPlayer = async (_isWon) => {
  appState.gameWonByPlayer = _isWon;
};
const setActualResult = async (_result) => {
  appState.actualResult = _result;
};
const contractIdentity = async () => {
  return appState.contractIdentity;
};

////////////////////

///////////
//Blockchain functions
///////////

//send all game state data to the Relay.sol smart contract
const sendAllUserData = async (
  _playerAddress,
  _gameWonByPlayer,
  _playerGuess,
  _actualResult,
  _betAmount,
  _gamesPlayed,
  _accessToken,
  _isGameActive
) => {
  const contractId = ContractId.fromString(process.env.RELAY_CONTRACT_ID);
  const contract = await new ContractCallQuery()
    .setContractId(contractId)
    .setGas(100000000)
    .setFunction("relayAllData", [
      _playerAddress,
      _gameWonByPlayer,
      _playerGuess,
      _actualResult,
      _betAmount,
      _gamesPlayed,
      _accessToken,
      _isGameActive,
    ])

    .execute(client);
  return contract;
};
const setplayerAddress = async (id) => {
  //must be an hbar address 0.0.123456
  if (!id.match(/^[0-9]+\.[0-9]+\.[0-9]+$/)) {
    throw new Error("Invalid input. Only a valid hbar address is allowed.");
  }
  appState.playerAddress = id;
};

const setPlayerGuess = async (_guess) => {
  appState.playerGuess = _guess;
};

const setWalletConnected = (_isConnected, _token) => {
  if (typeof _isConnected !== Boolean) {
    throw new Error("Invalid input. Only a boolean value is allowed.");
  }
  appState.walletConnected = _isConnected;
  appState.walletConnected = _isConnected;
  appState.walletAccessToken = _token;
  playerAddress = window.hashconnect.walletMetadata.accountIds[0];
  walletAccessToken = window.hashconnect.walletMetadata.accessToken;
};

const setReceipt = async (_receipt) => {
  appState.transferReceipt = _receipt;
  appState.transferReceipt = _receipt;
};

const getWalletToken = () => {
  return appState.walletAccessToken;
};

const setBetAmount = async (amount) => {
  appState.betAmouont = amount;
};
const runRandomNumber = async () => {
  try {
    //Create the transaction with range set
    const transaction = await new PrngTransaction()
      //Set the range
      .setRange(1)
      .execute(client);

    //Get the record
    const transactionRecord = await transaction.getRecord(client);

    //Get the number
    const randomNumber = transactionRecord.prngNumber;
    //get the transaction receipt and store it in the logs smart contract
    const receipt = transactionRecord.receipt;
    //store the receipt in the logs smart contract
    //store the receipt in the app state
    appState.randomReceipt = receipt;

    //heads = 1, tails = 0
    return randomNumber;
  } catch (error) {
    console.error(error);
  }
};

const flipCoin = async () => {
  const randomNumber = await runRandomNumber();
  if (randomNumber === 1) {
    return "Heads";
  } else if (randomNumber === 0) {
    return "Tails";
  }
};

/////////
//check that the wallets have enough hbar
///////////
const placeBet = async (_betAmount) => {
  try {
    const playerBalance = await client.accountInfo(playerAddress);
    const contractBalance = await client.accountInfo(appState.contractIdentity);

    if (playerBalance < _betAmount) {
      throw new Error("Insufficient balance to place bet");
    }
    if (contractBalance < _betAmount) {
      throw new Error(
        "Contract does not have sufficient balance to pay out bet"
      );
    }
    appState.betAmount = _betAmount;
  } catch (error) {
    globalErrorState.hasError = true;
    globalErrorState.message = error.message;
    handleError(globalErrorState);
  }
};

///////////
///Transfer funds to the player or the contract based on the outcome of the game
///////////
const payOut = async () => {
  let playerTransfer = 0;
  let contractTransfer = 0;
  let accessToken;
  const cid = await contractIdentity();
  if (appState.gameWonByPlayer) {
    accessToken = await getWalletToken();
    //player won so deduct from contract
    playerTransfer = appState.betAmount;
    contractTransfer = -appState.betAmount;
  } else {
    accessToken = await getWalletToken();
    //player lost so deduct from player
    playerTransfer = -appState.betAmount;
    contractTransfer = appState.betAmount;
    //access token is equal to contract
  } //key to allow contract to transfer
  //funds to player
  const transferTx = await new TransferTransaction()
    .addHbarTransfer(playerAddress, playerTransfer)
    .addHbarTransfer(cid, contractTransfer)
    .setAccessToken(accessToken)
    .execute(client);
  const transferReceipt = await transferTx.getReceipt(client);
  console.log("Transfer receipt: ", transferReceipt);
  setReceipt(transferReceipt);
};

////////////////
///Global error state object
////////////////
const globalErrorState = {
  hasError: false,
  message: "",
};

// Global error handler function
const handleError = () => {
  if (globalErrorState.hasError) {
    console.log("An error occurred: " + globalErrorState.message);
    setGamePhase("Error");
    globalErrorState.hasError = true;

    // Clear the error state
    globalErrorState.hasError = false;
    globalErrorState.message = "";
  }
};

module.exports = {
  setAppState,
  setGamePhase,
  flipCoin,
  runRandomNumber,
  placeBet,
  sendAllUserData,
  setplayerAddress,
  setBetAmount,
  setPlayerGuess,
  setGameWonByPlayer,
  setActualResult,
  setWalletConnected,
  payOut,
};
